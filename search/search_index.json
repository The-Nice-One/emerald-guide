{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note that this guide for Emerlad Game Engine is unofficial! Regardless, in this guide your will learn the fundamentals of Emerald Game Engine. This guide includes annotated examples as well as projects to make stuff fun and easy to understand. The guide is currently under development and is not completed yet. Make sure to checkout Emerald Game Engine Github !","title":"Quick Message"},{"location":"Drawing_A_Shape/","text":"This is the first of many projects we will create together so you can learn to use Emerald Game Engine! The Setup Lets use the a modified version of code that we made previously in the \"Game Setup\" section (I have outlined all the changes I made to the code): // Any line that has a comment, has been modified use emerald::*; fn main() { emerald::start(Box::new(Window {..Default::default()}), config_settings()) // Since we gave the... // ...Default trait to our Window structure we added \"..Default::default()\" to default the attributes } #[derive(Default)] // We will be giving the Window struct the default trait, so the MyRect struct will also need the default trait struct MyRect { // This structure will control the shape we will draw, in this case a rectangle rect: ColorRect, // ColorRect is a structure from Emerald, which represents a rectangle x: f32, // This will be the x position of the rectangle y: f32, // This will be the y position of the rectangle } #[derive(Default)] // We are giving the Window strucuture the Default trait to make things easier struct Window { shape: MyRect // The shape we will draw will be the MyRect structure we made } impl Game for Window { fn initialize(&mut self, mut emd: Emerald) { } fn update(&mut self, mut emd: Emerald) { } fn draw(&mut self, mut emd: Emerald) { } } fn config_settings() -> GameSettings { let mut settings = GameSettings::default(); let render_settings = RenderSettings { resolution: (500, 500), ..Default::default() }; settings.render_settings = render_settings; settings.title = \"Drawing A Shape\".to_string(); settings } Initializing our Rectangle Hopefully you already noticed, but the shape we will be drawing is a rectangle! In our initialize function of our Window strucutre lets create a MyRect strucuture: // code above fn initialize(&mut self, mut emd: Emerald) { self.shape = MyRect { // We use our MyRect struct to store the information of the shape we will draw rect: ColorRect::new(BLACK, 50, 50), // Using the ColorRect struct from Emerald we create a rectangle with the color black, with a width of 50 and a height of 50. x:25.0, // This will represent the x position of the rectangle y:250.0 // This will represent the y position of the rectangle }; // We store the MyRect struct in our shape attribute } // code below Rendering our Rectangle Currently we created a struct that will store the information for the rectangle we will draw. Now lets actually draw a rectangle to our window. // code above fn draw(&mut self, mut emd: Emerald) { emd.graphics().begin(); // This method will make Emerald start drawing to the Window // We will use the draw_color_rect method to draw the rectangle // The first argument is a reference to a ColorRect struct from Emerald // The second argument is a reference to a Transform struct from Emerald // In this case lets use the from_translation method of Emerald, to create a Transform struct // The first argument of the Transform struct is the x position of the rectangle // The second argument of the Transform struct is the y position of the rectangle emd.graphics() .draw_color_rect(&self.shape.rect, &Transform::from_translation((self.shape.x, self.shape.y))) .unwrap(); emd.graphics().render(); // This method renders everything that has been drawn on the Window } // code below Updating our Rectangle If we compile and run our code right now, we should see a rectangle drawn on the left side of the Window. Lets now make the rectangle move to the right every frame! fn update(&mut self, mut emd: Emerald) { self.shape.x += 0.5; // Its quite simple, just changing the x position of the rectangle by 0.5 } Conclusion The key takeaway from this project was to get used to how to use the 3 methods of our Window! Click here to view Source Code! use emerald::*; fn main() { emerald::start(Box::new(Window {..Default::default()}), config_settings()) } #[derive(Default)] struct MyRect { rect: ColorRect, x: f32, y: f32, } #[derive(Default)] struct Window { shape: MyRect } impl Game for Window { fn initialize(&mut self, mut emd: Emerald) { self.shape = MyRect { rect: ColorRect::new(BLACK, 50, 50), x:25.0, y:250.0 }; } fn update(&mut self, mut emd: Emerald) { self.shape.x += 0.5; } fn draw(&mut self, mut emd: Emerald) { emd.graphics().begin(); emd.graphics() .draw_color_rect(&self.shape.rect, &Transform::from_translation((self.shape.x, self.shape.y))) .unwrap(); emd.graphics().render(); } } fn config_settings() -> GameSettings { let mut settings = GameSettings::default(); let render_settings = RenderSettings { resolution: (500, 500), ..Default::default() }; settings.render_settings = render_settings; settings.title = \"Drawing A Shape\".to_string(); settings }","title":"Drawing A Shape"},{"location":"Drawing_A_Shape/#the-setup","text":"Lets use the a modified version of code that we made previously in the \"Game Setup\" section (I have outlined all the changes I made to the code): // Any line that has a comment, has been modified use emerald::*; fn main() { emerald::start(Box::new(Window {..Default::default()}), config_settings()) // Since we gave the... // ...Default trait to our Window structure we added \"..Default::default()\" to default the attributes } #[derive(Default)] // We will be giving the Window struct the default trait, so the MyRect struct will also need the default trait struct MyRect { // This structure will control the shape we will draw, in this case a rectangle rect: ColorRect, // ColorRect is a structure from Emerald, which represents a rectangle x: f32, // This will be the x position of the rectangle y: f32, // This will be the y position of the rectangle } #[derive(Default)] // We are giving the Window strucuture the Default trait to make things easier struct Window { shape: MyRect // The shape we will draw will be the MyRect structure we made } impl Game for Window { fn initialize(&mut self, mut emd: Emerald) { } fn update(&mut self, mut emd: Emerald) { } fn draw(&mut self, mut emd: Emerald) { } } fn config_settings() -> GameSettings { let mut settings = GameSettings::default(); let render_settings = RenderSettings { resolution: (500, 500), ..Default::default() }; settings.render_settings = render_settings; settings.title = \"Drawing A Shape\".to_string(); settings }","title":"The Setup"},{"location":"Drawing_A_Shape/#initializing-our-rectangle","text":"Hopefully you already noticed, but the shape we will be drawing is a rectangle! In our initialize function of our Window strucutre lets create a MyRect strucuture: // code above fn initialize(&mut self, mut emd: Emerald) { self.shape = MyRect { // We use our MyRect struct to store the information of the shape we will draw rect: ColorRect::new(BLACK, 50, 50), // Using the ColorRect struct from Emerald we create a rectangle with the color black, with a width of 50 and a height of 50. x:25.0, // This will represent the x position of the rectangle y:250.0 // This will represent the y position of the rectangle }; // We store the MyRect struct in our shape attribute } // code below","title":"Initializing our Rectangle"},{"location":"Drawing_A_Shape/#rendering-our-rectangle","text":"Currently we created a struct that will store the information for the rectangle we will draw. Now lets actually draw a rectangle to our window. // code above fn draw(&mut self, mut emd: Emerald) { emd.graphics().begin(); // This method will make Emerald start drawing to the Window // We will use the draw_color_rect method to draw the rectangle // The first argument is a reference to a ColorRect struct from Emerald // The second argument is a reference to a Transform struct from Emerald // In this case lets use the from_translation method of Emerald, to create a Transform struct // The first argument of the Transform struct is the x position of the rectangle // The second argument of the Transform struct is the y position of the rectangle emd.graphics() .draw_color_rect(&self.shape.rect, &Transform::from_translation((self.shape.x, self.shape.y))) .unwrap(); emd.graphics().render(); // This method renders everything that has been drawn on the Window } // code below","title":"Rendering our Rectangle"},{"location":"Drawing_A_Shape/#updating-our-rectangle","text":"If we compile and run our code right now, we should see a rectangle drawn on the left side of the Window. Lets now make the rectangle move to the right every frame! fn update(&mut self, mut emd: Emerald) { self.shape.x += 0.5; // Its quite simple, just changing the x position of the rectangle by 0.5 }","title":"Updating our Rectangle"},{"location":"Drawing_A_Shape/#conclusion","text":"The key takeaway from this project was to get used to how to use the 3 methods of our Window! Click here to view Source Code! use emerald::*; fn main() { emerald::start(Box::new(Window {..Default::default()}), config_settings()) } #[derive(Default)] struct MyRect { rect: ColorRect, x: f32, y: f32, } #[derive(Default)] struct Window { shape: MyRect } impl Game for Window { fn initialize(&mut self, mut emd: Emerald) { self.shape = MyRect { rect: ColorRect::new(BLACK, 50, 50), x:25.0, y:250.0 }; } fn update(&mut self, mut emd: Emerald) { self.shape.x += 0.5; } fn draw(&mut self, mut emd: Emerald) { emd.graphics().begin(); emd.graphics() .draw_color_rect(&self.shape.rect, &Transform::from_translation((self.shape.x, self.shape.y))) .unwrap(); emd.graphics().render(); } } fn config_settings() -> GameSettings { let mut settings = GameSettings::default(); let render_settings = RenderSettings { resolution: (500, 500), ..Default::default() }; settings.render_settings = render_settings; settings.title = \"Drawing A Shape\".to_string(); settings }","title":"Conclusion"},{"location":"Game_Setup/","text":"The Game Window The first thing we will do is create a new window where our game will be played. Here is a annotated example of creating a game window: // We will first bring the modules/functions of Emerald into scope with the \"use\" keyword use emerald::*; fn main() { // In our main function we are starting up our game window with the start function from Emerald // the first parameter in the start function is a structure with the Game trait. // the second parameter is the game settings which must be a GameSettings structure. // In this case we are setting the game settings to default emerald::start(Box::new(Window {}), GameSettings::default()) } // This is the main structure for our game struct Window {} // We need to implement the Game trait from Emerald into our main structure for our game. impl Game for Window { // There are 3 functions for the Game trait, which are: // initialize - called when the game window is created, commonly used for loading assets // update - called when the game updates after every frame, commonly used for updating game logic // draw - called when the game updates after every frame, commonly used for drawing to the window fn initialize(&mut self, mut emd: Emerald) { } fn update(&mut self, mut emd: Emerald) { } fn draw(&mut self, mut emd: Emerald) { } } The Game Settings When creating our game window in the last example, we were using Emeralds default settings. Instead lets now set out own game settings for our game. Lets create a function that will return our game settings for our game window: use emerald::*; fn config_settings() -> GameSettings { // The GameSettings consists of two attributes: // title - The title that will be displayed on the game window // render_settings - A RenderSettings structure from Emerald, that is used to configure the game window // Store a default version of the GameSettings structure let mut settings = GameSettings::default(); // We now create our own RenderSettings let render_settings = RenderSettings { // All attributes are optional, which means you do not have to specify each attribute background_color: Color, // the color of the background, Must be a Color structure from Emerald fullscreen: bool, // whether to fullscreen the game window. false by default resolution: (u32, u32), // The resolution/size of the game window high_dpi: bool, // whether to request a full-resolution framebuffer on HighDPI displays resizable_window: bool, // whether the game window is resizable icon: Option<Icon>, // An Icon strucute from Emerald, which sets the games icons ..Default::default() // we will use this to default the unspecified attributes }; // An example RenderSettings structure: // I didn't set the high_dpi and icon attributes in the sample settings as we will cover these later // RenderSettings { // background_color: emerald::colors::Color{r:255, g:255, b:255, a:255}, // fullscreen: false, // resolution: (500, 300), // resizable_window: true, // }; // Set the render_settings attribute of our settings structure to the RenderSettings we created settings.render_settings = render_settings; // Set the title for our game window (window title) settings.title = \"Random Game\".to_string(); // Return the game settings for our game window settings } A Small Modification Great! With this function all done, we can now replace some stuff in the emerald::start() function: // Before: emerald::start(Box::new(Window {}), GameSettings::default()) // After: emerald::start(Box::new(Window {}), config_settings()) Lets now compile and run our code with the following command: cargo run","title":"Game Setup"},{"location":"Game_Setup/#the-game-window","text":"The first thing we will do is create a new window where our game will be played. Here is a annotated example of creating a game window: // We will first bring the modules/functions of Emerald into scope with the \"use\" keyword use emerald::*; fn main() { // In our main function we are starting up our game window with the start function from Emerald // the first parameter in the start function is a structure with the Game trait. // the second parameter is the game settings which must be a GameSettings structure. // In this case we are setting the game settings to default emerald::start(Box::new(Window {}), GameSettings::default()) } // This is the main structure for our game struct Window {} // We need to implement the Game trait from Emerald into our main structure for our game. impl Game for Window { // There are 3 functions for the Game trait, which are: // initialize - called when the game window is created, commonly used for loading assets // update - called when the game updates after every frame, commonly used for updating game logic // draw - called when the game updates after every frame, commonly used for drawing to the window fn initialize(&mut self, mut emd: Emerald) { } fn update(&mut self, mut emd: Emerald) { } fn draw(&mut self, mut emd: Emerald) { } }","title":"The Game Window"},{"location":"Game_Setup/#the-game-settings","text":"When creating our game window in the last example, we were using Emeralds default settings. Instead lets now set out own game settings for our game. Lets create a function that will return our game settings for our game window: use emerald::*; fn config_settings() -> GameSettings { // The GameSettings consists of two attributes: // title - The title that will be displayed on the game window // render_settings - A RenderSettings structure from Emerald, that is used to configure the game window // Store a default version of the GameSettings structure let mut settings = GameSettings::default(); // We now create our own RenderSettings let render_settings = RenderSettings { // All attributes are optional, which means you do not have to specify each attribute background_color: Color, // the color of the background, Must be a Color structure from Emerald fullscreen: bool, // whether to fullscreen the game window. false by default resolution: (u32, u32), // The resolution/size of the game window high_dpi: bool, // whether to request a full-resolution framebuffer on HighDPI displays resizable_window: bool, // whether the game window is resizable icon: Option<Icon>, // An Icon strucute from Emerald, which sets the games icons ..Default::default() // we will use this to default the unspecified attributes }; // An example RenderSettings structure: // I didn't set the high_dpi and icon attributes in the sample settings as we will cover these later // RenderSettings { // background_color: emerald::colors::Color{r:255, g:255, b:255, a:255}, // fullscreen: false, // resolution: (500, 300), // resizable_window: true, // }; // Set the render_settings attribute of our settings structure to the RenderSettings we created settings.render_settings = render_settings; // Set the title for our game window (window title) settings.title = \"Random Game\".to_string(); // Return the game settings for our game window settings }","title":"The Game Settings"},{"location":"Game_Setup/#a-small-modification","text":"Great! With this function all done, we can now replace some stuff in the emerald::start() function: // Before: emerald::start(Box::new(Window {}), GameSettings::default()) // After: emerald::start(Box::new(Window {}), config_settings()) Lets now compile and run our code with the following command: cargo run","title":"A Small Modification"},{"location":"Install_Emerald/","text":"Install from crates.io You can install Emerald Game Engine by adding the following line to your Cargo.toml file: emerald = \"0.2.1\" Install from GitHub You can install Emerald Game Engine by adding the following line to your Cargo.toml file: emerald = { git = \"https://github.com/Bombfuse/emerald\" }","title":"Install Emerald"},{"location":"Install_Emerald/#install-from-cratesio","text":"You can install Emerald Game Engine by adding the following line to your Cargo.toml file: emerald = \"0.2.1\"","title":"Install from crates.io"},{"location":"Install_Emerald/#install-from-github","text":"You can install Emerald Game Engine by adding the following line to your Cargo.toml file: emerald = { git = \"https://github.com/Bombfuse/emerald\" }","title":"Install from GitHub"},{"location":"The_ECS/","text":"currently under development","title":"Entity Component System"},{"location":"android/","text":"currently under development","title":"Building for Android"},{"location":"aseprite/","text":"currently under development","title":"Aseprite Animations"},{"location":"audio/","text":"currently under development","title":"Audio Mixers"},{"location":"buttons/","text":"currently under development","title":"Buttons"},{"location":"camera/","text":"currently under development","title":"Managing the Camera"},{"location":"dynamic_resizing/","text":"currently under development","title":"Dynamic Resizing"},{"location":"flappy_bird/","text":"currently under development","title":"Flappy Bird!"},{"location":"physics/","text":"currently under development","title":"Physics and Collision"},{"location":"rpg/","text":"currently under development","title":"Creating a RPG Game"},{"location":"save/","text":"currently under development","title":"Saving Data"},{"location":"settings/","text":"currently under development","title":"Extra Window Settings"},{"location":"tilemap/","text":"currently under development","title":"TileMaps"},{"location":"wasm/","text":"currently under development","title":"Building for WASM"}]}